
包类型和格式
===============


QUIC公共包头
-----------------

传输的所有 QUIC 包以大小介于1至19字节的公共包头开始。公共包头的格式如下：::

          0         1       2        3        4            8
          +---------+--------+--------+--------+--------+---   ---+
          | Public  | Connection ID (0, 8, 32, or 64)       ...   | ->
          | Flags(8)| (variable length)                           |
          +---------+--------+--------+--------+--------+---   ---+


           9        10      11       12
          +--------+--------+--------+--------+
          |         QUIC Version (32)         | ->
          |            (optional)             |
          +--------+--------+--------+--------+


            13 14 15 16 17 18
            +--------+--------+--------+--------+--------+--------+
            | Packet Number (8, 16, 32, or 48)                    |
            | (variable length)                                   |
            +--------+--------+--------+--------+--------+--------+


载荷可以包含多个如下所述类型相关的头部字节。

公共头部中的字段如下：

* 公共标记（Public Flags）：

    * 0x01 = PUBLIC_FLAG_VERSION。这个标记的含义与包是由服务器还是客户端发送的有关。
      当由客户端发送时，设置它表示头部包含 QUIC 版本 (参考下面的说明)。
      客户端必须在所有的包中设置这个位，直到客户端收到来自服务器的确认，同意所提议的版本。
      服务器通过发送不设置该位的包来表示同意版本。当这个位由服务器设置时，包是版本协商包。
      版本协商在后面更详细地描述。
    * 0x02 = PUBLIC_FLAG_RESET。设置来表示包是公共复位包。
    * 0x0C处的两个比特指示分组中存在的连接ID的大小。 在所有分组中必须将这些比特设置为0x0C，
      直到给定方向协商更换为一个不同的值（例如，客户端可以请求呈现更少的连接ID字节）。

            * 0x0C 表示连接ID占了8个字节
            * 0x08 表示连接ID占了4个字节
            * 0x04 表示连接ID占了1个字节
            * 0x00  表示连接ID被删除了

    * 0x30 处的两位表示每个包中存在的数据包编号的低位字节数。
      这些位只用于帧包。没有包号的公共复位和版本协商包 (由服务器发送) ，
      不使用这些位，且必须被设置为0。这2位的掩码：

        * 0x30 表示包号占用6个字节。
        * 0x20 表示包号占用4个字节。
        * 0x10 表示包号占用2个字节。
        * 0x00 表示包号占用1个字节。

    * 0x40 为多路径使用保留。
    * 0x80 暂时未使用，且必须被设置为0。

* 连接ID：这是客户端选择的无符号64位统计随机数，该数字是连接的标识符。由于 QUIC 的连接被设计为，即使客户端漫游，连接依然保持建立状态，
  因而 IP 4元组（源IP，源端口，目标IP，目标端口）可能不足以标识连接。对每个传输方向，当4元组足以标识连接时，连接ID可以省略。

* QUIC版本：表示 QUIC 协议版本的32位不透明标记。只有在公共标记包含 FLAG\_VERSION（比如 public\_flags & FLAG\_VERSION !=0） 时才存在。
  客户端可以设置这个标记，并 准确 包含一个提议版本，同时包含任意的数据（与该版本一致）。

  当客户端提议的版本不支持时，服务器可以设置这个标记，并可以提供一个可接受版本的列表（0或多个），
  但一定不能(MUST not) 在版本信息之后包含任何数据。最近的实验版本的版本值示例包括 “Q025”，
  它对应于 byte 9 包含 ‘Q”，byte 10 包含 ‘0”，等等。[参考本文末尾的不同版本变化列表。]

* 包号：包号的低 8，16，32，或 48 位，基于公共标记的 FLAG\_?BYTE_SEQUENCE_NUMBER 标记被设置为什么。
  每个普通包（与特别的公共复位和版本协商包相反）由发送者分配包号。由某一端发送的首包包号应该为1，后续每个包的包号应该比前一个的大1。

  包号的低64位被用作加密随机数的一部分；然而，QUIC 端点一定不能发送其包号无法以 64 位表示的包。如果 QUIC 端点传输了包号为 (2^64-1) 的包，
  则该包必须包含错误码为 QUIC_SEQUENCE_NUMBER_LIMIT_REACHED 的 CONNECTION_CLOSE 帧，且对端一定不能再传输任何其它包。

  最多传输包号的低48位。要使接收者可以明确的重建包号，QUIC端点一定不能传输一个确认包已知已经由接收者发送的最大包号大 (2^(bitlength-2))
  的包。然而，在途包的数目不能超过 (2^46)。

  任何截断的包号应该被推断为具有最接近但大于传输最初包含了截断包号的包的对端的最大已知包号的值。包号的发送部分匹配推断值的最低位。


公共标记处理流程图如下：::

    Check the public flags in public header
                      |
                      |
                      V
              +--------------+
              | Public Reset |     YES
              | flag set?    |---------------> Public Reset Packet
              +--------------+
                      |
                      | NO
                      V
              +------------+           +-------------+
              | Version    | YES       | Packet sent | YES
              | flag set?  |---------> | by server?  |--------> Version Negotiation
              +------------+           +-------------+                Packet
                     |                        |
                     | NO                     | NO
                     V                        V
              Regular Packet         Regular Packet with
                                 QUIC Version present in header

特殊包
-------------

版本协商包
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

只有服务器会发送版本协商包。版本协商包以8位的公共标记和64位的连接ID开始。
公共标记必须设置PUBLIC_FLAG_VERSION，并指明64位的连接ID。
版本协商包的其余部分是服务器支持的版本的4字节列表：::


    .    0        1        2        3        4        5        6        7       8
    +--------+--------+--------+--------+--------+--------+--------+--------+--------+
    | Public |    Connection ID (64)                                                 | ->
    |Flags(8)|                                                                       |
    +--------+--------+--------+--------+--------+--------+--------+--------+--------+

         9       10       11        12       13      14       15       16       17
    +--------+--------+--------+--------+--------+--------+--------+--------+---...--+
    |      1st QUIC version supported   |     2nd QUIC version supported    |   ...
    |      by server (32)               |     by server (32)                |
    +--------+--------+--------+--------+--------+--------+--------+--------+---...--+

公共复位包
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

公共复位包以8位的公共标记和64位的连接ID开始。公共标记必须设置 PUBLIC_FLAG_RESET，并表明64位的连接ID。
公共复位包的其余部分像标记 PRST 的加密握手消息那样编码（参考[QUIC-CRYPTO]）：::


    .    0        1        2        3        4         8
    +--------+--------+--------+--------+--------+--   --+
    | Public |    Connection ID (64)                ...  | ->
    |Flags(8)|                                           |
    +--------+--------+--------+--------+--------+--   --+

         9       10       11        12       13      14
    +--------+--------+--------+--------+--------+--------+---
    |      Quic Tag (32)                |  Tag value map      ... ->
    |         (PRST)                    |  (variable length)
    +--------+--------+--------+--------+--------+--------+---

标记值映射：标记值映射包含如下的标记值：

* RNON (public reset nonce proof) - 一个64位的无符号整数。必须。
* RSEQ (rejected packet number) - 一个64位的包号。必须。
* CADR (client address) - 观察到的客户端IP地址和端口号。它当前只被用于调试，因而是可选的。

(TODO：公共复位包应该包含认证的（目标）服务器 IP/端口。)

普通包
----------

普通包已经过认证和加密。公共头部已认证但未加密，从第一帧开始的包的其余部分已加密。
紧随公共头部之后，普通包包含 AEAD（authenticated encryption and associated data）数据。
要解释内容，这些数据必须先解密。解密之后，明文以私有表头（Private Header）开头。::

                0        1
                +---------+---------+
                | Private | FEC (8) |
                | Flags(8)| (opt)   |
                +---------+---------+


私有表头中的字段如下：

* 私有标志

    * 0x01 =  FLAG_ENTROPY - 对于数据分组，表示该分组包含1比特的熵，对于fec分组，包含受保护分组的熵的异或。
    * 0x02 = FLAG_FEC_GROUP - 表示是否存在fec字节。
    * 0x04 = FLAG_FEC - 表示该数据包表示FEC数据包。

* FEC (FEC组编号偏移): FEC组编号是FEC组中第一个数据包的包编号。
  FEC组编号偏移是一个8位无符号值，应从当前数据包的包编号中减去该编号，以产生该包的FEC组编号。
  仅当私有标志包含FLAG_FEC_GROUP时才会出现此情况。
  单个FEC组内的所有数据包必须具有编码为相同字节数的数据包编号（即，数据包编号编码在组中不得更改）

(TODO: 文档化加密和解密的输入，并描述试用解密)


帧包
^^^^^^^^

在私人表头的格式之外，帧包具有一个载荷，它是一系列的类型前缀帧。帧类型的格式将在本文档的后面定义，但帧包的通用格式如下：::


    +--------+---...---+--------+---...---+
    | Type   | Payload | Type   | Payload |
    +--------+---...---+--------+---...---+

FEC包
^^^^^^^^^^^^


FEC分组（具有FLAG_FEC集的那些分组）具有载荷：其仅包含FEC组中的每个数据分组的空填充有效载荷的XOR。
FEC数据包还必须设置FLAG_FEC_GROUP。::

    +-----...----+
    | Redundancy |
    +-----...----+
